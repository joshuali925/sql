<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Overview &#8212; sql-docs  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=12dfc556" />
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="overview">
<h1>Overview<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h1>
<p>Build federated PPL query engine to fetch data from multiple data sources.</p>
<section id="motivation">
<h2>1. Motivation<a class="headerlink" href="#motivation" title="Link to this heading">¶</a></h2>
<p>PPL(Piped Processing Language) serves as the de-facto query language for all the observability solutions(Event Explorer, Notebooks, Trace Analytics) built on OpenSearch Dashboards. In the current shape, PPL engine can only query from OpenSearch and this limits observability solutions to leverage data from other data sources. As part of this project, we want to build framework to support multiple data sources and initially implement support for metric data stores like Prometheus and AWS Cloudwatch. This federation will also help in injecting data from different sources to ML commands, correlate metrics and logs from different datasources.</p>
</section>
<section id="glossary">
<h2>2. Glossary<a class="headerlink" href="#glossary" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p><em>Observability :</em> The ability to understand whats happening inside your business/application using logs, traces, metrics and other data emitted from the application.</p></li>
</ul>
</section>
<section id="tenets">
<h2>3.Tenets<a class="headerlink" href="#tenets" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>Query interface should be agnostic of underlying data store.</p></li>
<li><p>Changes to PPL Query Language grammar should be simple and easy to onboard.</p></li>
<li><p>Component design should be extensible for supporting new data stores.</p></li>
</ul>
</section>
<section id="out-of-scope-for-the-design">
<h2>4.Out of Scope for the Design.<a class="headerlink" href="#out-of-scope-for-the-design" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>Join Queries across datasources is out of scope.</p></li>
<li><p>Distributed Query Execution is out of scope and the current execution will happen on single coordination node.</p></li>
</ul>
</section>
<section id="requirements">
<h2>5. Requirements<a class="headerlink" href="#requirements" title="Link to this heading">¶</a></h2>
<section id="functional">
<h3>5.1 <em>Functional</em><a class="headerlink" href="#functional" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>As an OpenSearch user, I should be able to configure and add a new data source with available connectors.</p></li>
<li><p>As an OpenSearch user, I should be able to query data from all the configured data sources using PPL.</p></li>
<li><p>As an Opensearch contributor, I should be able to add connectors for different data sources.</p></li>
</ul>
</section>
<section id="non-functional">
<h3>5.2 <em>Non Functional</em><a class="headerlink" href="#non-functional" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>Query Execution Plan should be optimized and pushed down as much as possible to underlying data stores.</p></li>
<li><p>Latency addition from query engine should be small when compared to that of underlying data stores.</p></li>
</ul>
</section>
</section>
<section id="high-level-design">
<h2>6. High Level Design<a class="headerlink" href="#high-level-design" title="Link to this heading">¶</a></h2>
<p><img alt="prometheus drawio(2)" src="https://user-images.githubusercontent.com/99925918/166970105-09855a1a-6db9-475f-9638-eb240022e399.svg" /></p>
<p>At high level, our design is broken down into below major sections.</p>
<ul class="simple">
<li><p>Data Source representation.</p>
<ul>
<li><p>This section speaks on the new constructs introduced in the query engine to support additional data sources.</p></li>
</ul>
</li>
<li><p>Query Engine Architecture Changes.</p>
<ul>
<li><p>This section gives an overview of the architecture and changes required for supporting multiple data sources.</p></li>
</ul>
</li>
<li><p>PPL grammar changes for metric data and details for implementing Prometheus Connector.</p></li>
</ul>
<section id="data-source-representation">
<h3>6.1 Data source representation.<a class="headerlink" href="#data-source-representation" title="Link to this heading">¶</a></h3>
<p>Below are the new constructs introduced to support additional datasources. These constructs helps in identfying and referring correct datasource for a particular query.</p>
<ul class="simple">
<li><p><em>Connector :</em> Connector is a component that adapts the query engine to a datasource. For eg: Prometheus connector would adapt and help execute the queries to run on Prometheus data source.</p></li>
<li><p><em>Catalog :</em> we can describe a catalog as the union of a connector and the underlying instance of the datasource being referred. This gives us flexbility to refer different instances of a similar datastore with the same connector i.e. we can refer data from multiple prometheus instances using prometheus connector. The name for each catalog should be different.</p></li>
</ul>
<p>Example Prometheus Catalog Definition</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[{</span>
    <span class="s2">&quot;name&quot;</span> <span class="p">:</span> <span class="s2">&quot;prometheus_1&quot;</span><span class="p">,</span>
    <span class="s2">&quot;connector&quot;</span><span class="p">:</span> <span class="s2">&quot;prometheus&quot;</span><span class="p">,</span> 
    <span class="s2">&quot;uri&quot;</span> <span class="p">:</span> <span class="s2">&quot;http://localhost:9090&quot;</span><span class="p">,</span>
    <span class="s2">&quot;authentication&quot;</span> <span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;type&quot;</span> <span class="p">:</span> <span class="s2">&quot;basicauth&quot;</span><span class="p">,</span>
        <span class="s2">&quot;username&quot;</span> <span class="p">:</span> <span class="s2">&quot;admin&quot;</span><span class="p">,</span>
        <span class="s2">&quot;password&quot;</span> <span class="p">:</span> <span class="s2">&quot;admin&quot;</span>
    <span class="p">}</span>
<span class="p">}]</span>
</pre></div>
</div>
<ul class="simple">
<li><p><em>Table :</em> A table is a set of unordered rows which are organized into named columns with types. The mapping from source data to tables is defined by the connector.</p></li>
<li><p>In order to query data from above Prometheus Catalog, Query would look like something below.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">source</span> <span class="pre">=</span> <span class="pre">prometheus_1.total_cpu_usage</span> <span class="pre">|</span> <span class="pre">stats</span> <span class="pre">avg(&#64;value)</span> <span class="pre">by</span> <span class="pre">region</span></code></p></li>
</ul>
</li>
<li><p>What will be the interface to add new catalogs?</p>
<ul>
<li><p>In the initial phase, we are trying to adopt a simple approach of storing the above configuration to opensearch-keystore. Since this catalog configuration contains credential data we are taking this input from the user via keystore(secure-setting)</p></li>
</ul>
</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">bin</span><span class="o">/</span><span class="n">opensearch</span><span class="o">-</span><span class="n">keystore</span> <span class="n">add</span><span class="o">-</span><span class="n">file</span> <span class="n">plugins</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">federation</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">config</span> <span class="n">catalog</span><span class="o">.</span><span class="n">json</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Catalog is optional and it will be defaulted to opensearch instance in which the PPL query engine plugin is running.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">source</span> <span class="pre">=</span> <span class="pre">accounts</span></code>, this is a valid query and the engine defaults to opensearch instance to get the data from.</p></li>
</ul>
</li>
</ul>
</section>
<section id="query-engine-architecture">
<h3>6.2  Query Engine Architecture.<a class="headerlink" href="#query-engine-architecture" title="Link to this heading">¶</a></h3>
<p>There are no major changes in the query engine flow as the current state is extensible to support new datastores.</p>
<p>Changes required</p>
<ul class="simple">
<li><p>Current StorageEngine and Table injection beans default to Opensearch Connector implementation. This should be dynamic and based on the catalog mentioned in the source command.</p></li>
</ul>
<p><img alt="PPL Execution flow" src="https://user-images.githubusercontent.com/99925918/163804980-8e1f5c07-4776-4497-97d5-7b2eec1ffb8e.svg" /></p>
<p>Interfaces to be implemented for supporting a new data source connector.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span><span class="w"> </span><span class="kd">interface</span> <span class="nc">StorageEngine</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="cm">/**</span>
<span class="cm">   * Get {@link Table} from storage engine.</span>
<span class="cm">   */</span>
<span class="w">  </span><span class="n">Table</span><span class="w"> </span><span class="nf">getTable</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span><span class="w"> </span><span class="kd">interface</span> <span class="nc">Table</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="cm">/**</span>
<span class="cm">   * Get the {@link ExprType} for each field in the table.</span>
<span class="cm">   */</span>
<span class="w">  </span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">ExprType</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">getFieldTypes</span><span class="p">();</span>

<span class="w">  </span><span class="cm">/**</span>
<span class="cm">   * Implement a {@link LogicalPlan} by {@link PhysicalPlan} in storage engine.</span>
<span class="cm">   *</span>
<span class="cm">   * @param plan logical plan</span>
<span class="cm">   * @return physical plan</span>
<span class="cm">   */</span>
<span class="w">  </span><span class="n">PhysicalPlan</span><span class="w"> </span><span class="nf">implement</span><span class="p">(</span><span class="n">LogicalPlan</span><span class="w"> </span><span class="n">plan</span><span class="p">);</span>

<span class="w">  </span><span class="cm">/**</span>
<span class="cm">   * Optimize the {@link LogicalPlan} by storage engine rule.</span>
<span class="cm">   * The default optimize solution is no optimization.</span>
<span class="cm">   *</span>
<span class="cm">   * @param plan logical plan.</span>
<span class="cm">   * @return logical plan.</span>
<span class="cm">   */</span>
<span class="w">  </span><span class="k">default</span><span class="w"> </span><span class="n">LogicalPlan</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="n">LogicalPlan</span><span class="w"> </span><span class="n">plan</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">plan</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span><span class="w"> </span><span class="kd">interface</span> <span class="nc">ExecutionEngine</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="cm">/**</span>
<span class="cm">   * Execute physical plan and call back response listener.</span>
<span class="cm">   *</span>
<span class="cm">   * @param plan     executable physical plan</span>
<span class="cm">   * @param listener response listener</span>
<span class="cm">   */</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="n">PhysicalPlan</span><span class="w"> </span><span class="n">plan</span><span class="p">,</span><span class="w"> </span><span class="n">ResponseListener</span><span class="o">&lt;</span><span class="n">QueryResponse</span><span class="o">&gt;</span><span class="w"> </span><span class="n">listener</span><span class="p">);</span>

<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="ppl-metric-grammar-and-prometheus-connector">
<h3>6.3 PPL Metric Grammar and Prometheus Connector.<a class="headerlink" href="#ppl-metric-grammar-and-prometheus-connector" title="Link to this heading">¶</a></h3>
<p>This section talks about metric grammar for PPL. Till now, PPL catered only for event data and language grammar was built around that. With the introduction of support for new metric data stores, we want to analyse and add changes changes to support metric data. As called out in tenets, we want to build simple intuitive grammar through which developers can easily onboard.</p>
<p><em>Key Characteristics of Metric Data</em></p>
<ul class="simple">
<li><p>Metric data is a timeseries vector. Below are the four major attributes of any metric data.</p>
<ul>
<li><p>Metric Name</p></li>
<li><p>Measured value</p></li>
<li><p>Dimensions</p></li>
<li><p>Timestamp</p></li>
</ul>
</li>
<li><p>Every time-series is uniquely identified by metric and a combination of value of dimensions.</p></li>
</ul>
<p>Since we don’t have column names similar to relational databases, <code class="docutils literal notranslate"><span class="pre">&#64;timestamp</span></code> and <code class="docutils literal notranslate"><span class="pre">&#64;value</span></code> are new internal keywords used to represent the time and measurement of a metric.</p>
<p><em>Types of metric queries</em>
<em><strong>These queries are inspired from widely used Prometheus data store.</strong></em></p>
</section>
<section id="passthrough-promql-support">
<h3>Passthrough PromQL Support.<a class="headerlink" href="#passthrough-promql-support" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>PromQL is easy to use powerful language over metrics and we want to support promQL queries from catalogs with prometheus connectors.</p></li>
<li><p>Function signature: source = <code class="docutils literal notranslate"><span class="pre">promcatalog.nativeQuery(`promQLCommand`,</span> <span class="pre">startTime</span> <span class="pre">=</span> <span class="pre">&quot;{{startTime}}&quot;,</span> <span class="pre">endTime=&quot;{{endTime}&quot;,</span> <span class="pre">step=&quot;{{resolution}}&quot;)</span></code></p></li>
</ul>
</section>
<section id="ppl-queries-on-prometheus">
<h3>PPL queries on prometheus.<a class="headerlink" href="#ppl-queries-on-prometheus" title="Link to this heading">¶</a></h3>
</section>
<section id="selecting-time-series">
<h3>1. Selecting Time Series<a class="headerlink" href="#selecting-time-series" title="Link to this heading">¶</a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>PromQL</p></th>
<th class="head"><p>PPL</p></th>
<th class="head"><p>Remarks</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">node_cpu_seconds_total</span></code></p></td>
<td><p>source = promcatalog.<code class="docutils literal notranslate"><span class="pre">node_cpu_seconds_total</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">node_cpu_seconds_total[5m]</span></code></p></td>
<td><p>source = promcatalog.<code class="docutils literal notranslate"><span class="pre">node_cpu_seconds_total</span></code> | where endtime = now() and starttime = now()-5m</p></td>
<td><p>we can either use <code class="docutils literal notranslate"><span class="pre">startime</span> <span class="pre">and</span> <span class="pre">endtime</span></code> ? or <code class="docutils literal notranslate"><span class="pre">&#64;timestamp</span> <span class="pre">&lt;</span> <span class="pre">now()</span> <span class="pre">and</span> <span class="pre">&#64;timstamp</span> <span class="pre">&gt;now()</span> <span class="pre">-</span> <span class="pre">5m</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">node_cpu_seconds_total{cpu=&quot;0&quot;,mode=&quot;idle&quot;}</span></code></p></td>
<td><p>source  = promcatalog.<code class="docutils literal notranslate"><span class="pre">node_cpu_seconds_total</span></code> | where  cpu = ‘0’ and mode = ‘idle’</p></td>
<td><p>This again got the same limitations as first query. Where should we stop the result set.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">process_resident_memory_bytes</span> <span class="pre">offset</span> <span class="pre">1d</span></code></p></td>
<td><p>source = promcatalog.<code class="docutils literal notranslate"><span class="pre">process_resident_memory_bytes</span></code> | where starttime = now()-1d and endtime = 1d</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<section id="limitations-and-solutions">
<h4>Limitations and Solutions<a class="headerlink" href="#limitations-and-solutions" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>How do we limit the output size of timeseries select query? We can’t output the entire history.</p>
<ul>
<li><p><strong>[Solution 1]</strong> Make <code class="docutils literal notranslate"><span class="pre">starttime</span></code> and <code class="docutils literal notranslate"><span class="pre">endtime</span></code> compulsory ?</p>
<ul>
<li><p>This will create validations based on the catalog used and the grammar be agnostic of the underlying catalog.</p></li>
</ul>
</li>
<li><p><strong>[Solution 2]</strong> Have a hard limit on the result set length. Let user don’t specify time range and dig deep into the timeseries until it hits the hard limit. For eg: In case of prometheus, How can we execute this under hood, there is no limit operator in promQl. The only limit we could set is the time range limit.</p></li>
<li><p><strong>[Proposed Solution 3]</strong> Have a default time range specified in the catalog configuration. If user specifies no filter on timerange in where clause, this default timerange will be applied similar to limiting eventData resultSet in the currrent day for OpenSearch.</p></li>
</ul>
</li>
</ul>
</section>
</section>
<section id="rates-of-increase-for-counters">
<h3>2. Rates of increase for counters<a class="headerlink" href="#rates-of-increase-for-counters" title="Link to this heading">¶</a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>PromQL</p></th>
<th class="head"><p>PPL</p></th>
<th class="head"><p>Remarks</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">rate(demo_api_request_duration_seconds_count[5m])</span></code></p></td>
<td><p>source = promcatalog.<code class="docutils literal notranslate"><span class="pre">demo_api_request_duration_seconds_count</span></code> | eval x = rate(&#64;value, 5m)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">irate(demo_api_request_duration_seconds_count[1m])</span></code></p></td>
<td><p>source = promcatalog.<code class="docutils literal notranslate"><span class="pre">demo_api_request_duration_seconds_count</span></code> | eval x = irate(&#64;value, 5m)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">increase(demo_api_request_duration_seconds_count[1h])</span></code></p></td>
<td><p>source = promcatalog.<code class="docutils literal notranslate"><span class="pre">demo_api_request_duration_seconds_count</span></code> | eval x = increase(&#64;value, 5m)</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>Should we output x along with &#64;value in two columns or restrict to rate function output,</p>
<ul>
<li><p>[timestamp, value, rate]  or [timestamp, x]</p></li>
</ul>
</li>
<li><p>If we push down the query to Prometheus we only get rate as output. Should we not push down and calculate on the coordination node?</p></li>
</ul>
</section>
<section id="aggregating-over-multiple-series">
<h3>3. Aggregating over multiple series<a class="headerlink" href="#aggregating-over-multiple-series" title="Link to this heading">¶</a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>PromQL</p></th>
<th class="head"><p>PPL</p></th>
<th class="head"><p>Remarks</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sum(node_filesystem_size_bytes)</span></code></p></td>
<td><p>source = promcatalog.<code class="docutils literal notranslate"><span class="pre">node_filesystem_size_bytes</span> </code>| stats sum(&#64;value) by span(&#64;timestamp, 5m)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sum</span> <span class="pre">by(job,</span> <span class="pre">instance)</span> <span class="pre">(node_filesystem_size_bytes)</span></code></p></td>
<td><p>source = promcatalog.<code class="docutils literal notranslate"><span class="pre">node_filesystem_size_bytes</span> </code>| stats sum(&#64;value) by instance, job span(&#64;timestamp, 5m)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sum</span> <span class="pre">without(instance,</span> <span class="pre">job)</span> <span class="pre">(node_filesystem_size_bytes)</span></code></p></td>
<td><p>source = promcatalog.<code class="docutils literal notranslate"><span class="pre">node_filesystem_size_bytes</span> </code>| stats sum(&#64;value) without instance, job</p></td>
<td><p>We dont have without support. We need to build that, we can group by fields other than instance, job.</p></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">sum()</span></code>, <code class="docutils literal notranslate"><span class="pre">min()</span></code>, <code class="docutils literal notranslate"><span class="pre">max()</span></code>, <code class="docutils literal notranslate"><span class="pre">avg()</span></code>, <code class="docutils literal notranslate"><span class="pre">stddev()</span></code>, <code class="docutils literal notranslate"><span class="pre">stdvar()</span></code>, <code class="docutils literal notranslate"><span class="pre">count()</span></code>, <code class="docutils literal notranslate"><span class="pre">count_values()</span></code>, <code class="docutils literal notranslate"><span class="pre">group()</span></code>, <code class="docutils literal notranslate"><span class="pre">bottomk()</span></code>, <code class="docutils literal notranslate"><span class="pre">topk()</span></code>, <code class="docutils literal notranslate"><span class="pre">quantile()</span> <span class="pre">Additional</span> <span class="pre">Aggregation</span> <span class="pre">Functions.</span> </code></p>
<ul class="simple">
<li><p>On time series, we calculate aggregations with in small buckets over a large period of time.  For eg: calculate the average over 5min for the last one hour. PromQL gets the time parameters from API parameters, how can we get these for PPL. Can we make these compulsory but that would make the language specific to metric datastore which doesn’t apply for event data store.</p></li>
<li><p>Can we have separate command mstats for metric datastore with compulsory span expression.</p></li>
</ul>
</section>
<section id="math-between-time-series-vector-operation-arithmetic">
<h3>4.  Math Between Time Series [Vector Operation Arithmetic]<a class="headerlink" href="#math-between-time-series-vector-operation-arithmetic" title="Link to this heading">¶</a></h3>
<p>Arithmetic between series. Allowed operators : , <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>PromQL</p></th>
<th class="head"><p>PPL</p></th>
<th class="head"><p>Remarks</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">node_memory_MemFree_bytes</span> <span class="pre">+</span> <span class="pre">node_memory_Cached_bytes</span></code></p></td>
<td><p>source = promcatalog.<code class="docutils literal notranslate"><span class="pre">node_memory_MemFree_bytes</span> <span class="pre">|</span></code> <code class="docutils literal notranslate"><span class="pre">vector_op</span></code>(+) promcatalog.<code class="docutils literal notranslate"><span class="pre">node_memory_Cached_bytes</span></code></p></td>
<td><p>Add all equally-labelled series from both sides:</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">node_memory_MemFree_bytes</span> <span class="pre">+</span> <span class="pre">on(instance,</span> <span class="pre">job)</span> <span class="pre">node_memory_Cached_bytes</span></code></p></td>
<td><p>source = promcatalog.<code class="docutils literal notranslate"><span class="pre">node_memory_MemFree_bytes</span> <span class="pre">|</span></code> <code class="docutils literal notranslate"><span class="pre">vector_op</span></code>(+) on(instance, job) promcatalog.<code class="docutils literal notranslate"><span class="pre">node_memory_Cached_bytes</span></code></p></td>
<td><p>Add series, matching only on the <code class="docutils literal notranslate"><span class="pre">instance</span></code> and <code class="docutils literal notranslate"><span class="pre">job</span></code> labels:</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">node_memory_MemFree_bytes</span> <span class="pre">+</span> <span class="pre">ignoring(instance,</span> <span class="pre">job)</span> <span class="pre">node_memory_Cached_bytes</span></code></p></td>
<td><p>source = promcatalog.<code class="docutils literal notranslate"><span class="pre">node_memory_MemFree_bytes</span> <span class="pre">|</span></code> <code class="docutils literal notranslate"><span class="pre">vector_op</span></code>(+) ignoring(instance, job) promcatalog.<code class="docutils literal notranslate"><span class="pre">node_memory_Cached_bytes</span></code></p></td>
<td><p>Add series, ignoring the <code class="docutils literal notranslate"><span class="pre">instance</span></code> and <code class="docutils literal notranslate"><span class="pre">job</span></code> labels for matching:</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">rate(demo_cpu_usage_seconds_total[1m])</span> <span class="pre">/</span> <span class="pre">on(instance,</span> <span class="pre">job)</span> <span class="pre">group_left</span> <span class="pre">demo_num_cpus</span></code></p></td>
<td><p>source = <code class="docutils literal notranslate"><span class="pre">rate(promcatalog.demo_cpu_usage_seconds_total[1m])</span> </code> | <code class="docutils literal notranslate"><span class="pre">vector_op</span></code>(/) on(instance, job) group_left promcatalog.<code class="docutils literal notranslate"><span class="pre">node_memory_Cached_bytes</span></code></p></td>
<td><p>Explicitly allow many-to-one matching:</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">node_filesystem_avail_bytes</span> <span class="pre">*</span> <span class="pre">on(instance,</span> <span class="pre">job)</span> <span class="pre">group_left(version)</span> <span class="pre">node_exporter_build_info</span></code></p></td>
<td><p>source = promcatalog.<code class="docutils literal notranslate"><span class="pre">node_filesystem_avail_bytes</span></code> | <code class="docutils literal notranslate"><span class="pre">vector_op</span></code>(*) on(instance, job) group_left(version) promcatalog.<code class="docutils literal notranslate"><span class="pre">node_exporter_build_info</span></code></p></td>
<td><p>Include the <code class="docutils literal notranslate"><span class="pre">version</span></code> label from “one” (right) side in the result:</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>Event data joins can have below grammar.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">source</span> <span class="pre">=</span> <span class="pre">lefttable</span> <span class="pre">|</span> <span class="pre">join</span> <span class="pre">righttable</span> <span class="pre">on</span> <span class="pre">columnName</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">source</span> <span class="pre">=</span> <span class="pre">lefttable</span> <span class="pre">|</span> <span class="pre">join</span> <span class="pre">righttable</span> <span class="pre">on</span> <span class="pre">$left.leftColumn</span> <span class="pre">=</span> <span class="pre">$right.rightColumn</span></code></p></li>
</ul>
</li>
<li><p>Metric data grammar. Since joins are mostly for vector arithmetic.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">source=leftTable</span> <span class="pre">|</span> <span class="pre">vector_op(operator)</span> <span class="pre">on|ignoring</span>&#160; <span class="pre">group_left|group_right</span> <span class="pre">rightTable</span> </code></p></li>
</ul>
</li>
<li><p>What would be a better keyword <code class="docutils literal notranslate"><span class="pre">vector_op</span></code> or <code class="docutils literal notranslate"><span class="pre">mjoin</span></code> or <code class="docutils literal notranslate"><span class="pre">{new}</span></code></p></li>
<li><p>Does vector_op has any meaning for event data.</p>
<ul>
<li><p>Can we restrict vector_op for metric data only?</p></li>
<li><p>If yes, How should we identify if something is of metric data type.</p></li>
<li><p>This can break the tenet of designing langauge grammar irrespective of the underlying datastore.</p></li>
</ul>
</li>
</ul>
</section>
<section id="filtering-series-by-value-vector-operation-comparitive">
<h3>5. Filtering series by value [Vector Operation Comparitive]<a class="headerlink" href="#filtering-series-by-value-vector-operation-comparitive" title="Link to this heading">¶</a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>PromQL</p></th>
<th class="head"><p>PPL</p></th>
<th class="head"><p>Remarks</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">node_filesystem_avail_bytes</span> <span class="pre">&gt;</span> <span class="pre">10*1024*1024</span></code></p></td>
<td><p>source = promcatalog.<code class="docutils literal notranslate"><span class="pre">node_filesystem_avail_bytes</span></code> |  <code class="docutils literal notranslate"><span class="pre">vector_op(&gt;)</span> <span class="pre">10*1024*1024</span></code></p></td>
<td><p>Only keep series with a sample value greater than a given number:</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">go_goroutines</span> <span class="pre">&gt;</span> <span class="pre">go_threads</span></code></p></td>
<td><p>source = promcatalog.<code class="docutils literal notranslate"><span class="pre">node_memory_MemFree_bytes</span></code> | <code class="docutils literal notranslate"><span class="pre">vector_op</span></code>(+) promcatalog.<code class="docutils literal notranslate"><span class="pre">node_memory_Cached_bytes</span></code></p></td>
<td><p>Only keep series from the left-hand side whose sample values are larger than their right-hand-side matches:</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">go_goroutines</span> <span class="pre">&gt;</span> <span class="pre">bool</span> <span class="pre">go_threads</span></code></p></td>
<td><p>source = promcatalog.<code class="docutils literal notranslate"><span class="pre">go_goroutines</span></code> | <code class="docutils literal notranslate"><span class="pre">vector_op</span></code>(&gt; bool) promcatalog.<code class="docutils literal notranslate"><span class="pre">go_threads</span></code></p></td>
<td><p>Instead of filtering, return <code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">1</span></code> for each compared series:</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">go_goroutines</span> <span class="pre">&gt;</span> <span class="pre">bool</span> <span class="pre">on(job,</span> <span class="pre">instance)</span> <span class="pre">go_threads</span></code></p></td>
<td><p>source = promcatalog.<code class="docutils literal notranslate"><span class="pre">go_goroutines</span></code> | <code class="docutils literal notranslate"><span class="pre">vector_op</span></code>(&gt; bool) on(job,instance) promcatalog.<code class="docutils literal notranslate"><span class="pre">go_threads</span></code></p></td>
<td><p>Match only on specific labels:</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>The above operations are similar to 4th section, except the operators are comparision operators instead of arithmetic,</p></li>
<li><p>The operations are always between <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">vector</span> <span class="pre">and</span> <span class="pre">scalar</span></code> or <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">vector</span> <span class="pre">and</span> <span class="pre">a</span> <span class="pre">vector</span></code></p></li>
</ul>
</section>
<section id="set-operations-vector-operation-logical">
<h3>6. Set operations [Vector Operation Logical]<a class="headerlink" href="#set-operations-vector-operation-logical" title="Link to this heading">¶</a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>PromQL</p></th>
<th class="head"><p>PPL</p></th>
<th class="head"><p>Remarks</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">up{job=&quot;prometheus&quot;}</span> <span class="pre">or</span> <span class="pre">up{job=&quot;node&quot;}</span></code></p></td>
<td><p>source = promcatalog.<code class="docutils literal notranslate"><span class="pre">up</span></code> | where job=”prometheus” | <code class="docutils literal notranslate"><span class="pre">vector_op(or)</span>&#160; <span class="pre">inner(</span></code>promcatalog.up | where job=”node”)</p></td>
<td><p>Only keep series with a sample value greater than a given number:</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">node_network_mtu_bytes</span> <span class="pre">and</span> <span class="pre">(node_network_address_assign_type</span> <span class="pre">==</span> <span class="pre">0)</span></code></p></td>
<td><p>source = promcatalog.<code class="docutils literal notranslate"><span class="pre">node_network_mtu_bytes</span></code> |  <code class="docutils literal notranslate"><span class="pre">vector_op(and)</span>&#160; <span class="pre">inner(</span></code>promcatalog.<code class="docutils literal notranslate"><span class="pre">node_network_address_assign_type</span></code> | <code class="docutils literal notranslate"><span class="pre">vector_op(==)</span> <span class="pre">0)</span></code></p></td>
<td><p>Include any label sets that are present both on the left and right side:</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">node_network_mtu_bytes</span> <span class="pre">unless</span> <span class="pre">(node_network_address_assign_type</span> <span class="pre">==</span> <span class="pre">1)</span></code></p></td>
<td><p>source = promcatalog.<code class="docutils literal notranslate"><span class="pre">node_network_mtu_bytes</span></code> | <code class="docutils literal notranslate"><span class="pre">vector_op(unless)</span>&#160; <span class="pre">inner(</span></code>promcatalog<code class="docutils literal notranslate"><span class="pre">node_network_address_assign_type</span></code> | <code class="docutils literal notranslate"><span class="pre">vector_op(==)</span> <span class="pre">1)</span> </code></p></td>
<td><p>Include any label sets from the left side that are not present in the right side:</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">node_network_mtu_bytes</span> <span class="pre">and</span> <span class="pre">on(device)</span> <span class="pre">(node_network_address_assign_type</span> <span class="pre">==</span> <span class="pre">0)</span></code></p></td>
<td><p>source = <code class="docutils literal notranslate"><span class="pre">promcatalog.</span></code>node_network_mtu_bytes<code class="docutils literal notranslate"> <span class="pre">|</span> <span class="pre">``</span> <span class="pre">vector_op(and)</span>&#160; <span class="pre">on(device)</span> <span class="pre">inner(</span></code>promcatalog.<code class="docutils literal notranslate"><span class="pre">node_network_address_assign_type</span> <span class="pre">|</span> <span class="pre">vector_op(==)</span> <span class="pre">1)</span> </code></p></td>
<td><p>Match only on specific labels:</p></td>
</tr>
</tbody>
</table>
</section>
<section id="quantiles-from-histograms">
<h3>7.Quantiles from histograms<a class="headerlink" href="#quantiles-from-histograms" title="Link to this heading">¶</a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>PromQL</p></th>
<th class="head"><p>PPL</p></th>
<th class="head"><p>Remarks</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">histogram_quantile(0.9,</span> <span class="pre">rate(demo_api_request_duration_seconds_bucket[5m]))</span></code></p></td>
<td><p>source = promcatalog.<code class="docutils literal notranslate"><span class="pre">demo_api_request_duration_seconds_bucket</span></code> | eval x = <code class="docutils literal notranslate"><span class="pre">rate</span></code>(&#64;value) | eval k = <code class="docutils literal notranslate"><span class="pre">histogram_quantile</span></code>(le=0.9,x)</p></td>
<td><p>90th percentile request latency over last 5 minutes, for every label dimension:</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">histogram_quantile(0.9,sum</span> <span class="pre">by(le,</span> <span class="pre">path,</span> <span class="pre">method)</span> <span class="pre">(rate(demo_api_request_duration_seconds_bucket[5m])))</span></code></p></td>
<td><p>source = promcatalog.<code class="docutils literal notranslate"><span class="pre">demo_api_request_duration_seconds_bucket</span></code> | eval x= <code class="docutils literal notranslate"><span class="pre">rate</span></code>(&#64;value, 5m) | stats <code class="docutils literal notranslate"><span class="pre">sum(x)</span></code> by (le,path,method)</p></td>
<td><p>90th percentile request latency over last 5 minutes, for only the <code class="docutils literal notranslate"><span class="pre">path</span></code> and <code class="docutils literal notranslate"><span class="pre">method</span></code> dimensions.</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>Can we apply nested functions?</p></li>
</ul>
</section>
<section id="changes-in-gauges">
<h3>8. Changes in gauges<a class="headerlink" href="#changes-in-gauges" title="Link to this heading">¶</a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>PromQL</p></th>
<th class="head"><p>PPL</p></th>
<th class="head"><p>Remarks</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">deriv(demo_disk_usage_bytes[1h])</span></code></p></td>
<td><p>source = promcatalog.<code class="docutils literal notranslate"><span class="pre">demo_disk_usage_bytes</span></code> | eval x = deriv(&#64;value, 1h)</p></td>
<td><p>Per-second derivative using linear regression:</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">predict_linear(demo_disk_usage_bytes[4h],</span> <span class="pre">3600)</span></code></p></td>
<td><p>source = promcatalog.<code class="docutils literal notranslate"><span class="pre">demo_disk_usage_bytes</span></code> | eval x = <code class="docutils literal notranslate"><span class="pre">predict_linear</span></code>(&#64;value, 4h, 3600)</p></td>
<td><p>Predict value in 1 hour, based on last 4 hours:</p></td>
</tr>
</tbody>
</table>
<p>Has the same drawbacks as earlier eval function commands.</p>
</section>
<section id="aggregating-over-time">
<h3>9.Aggregating over time<a class="headerlink" href="#aggregating-over-time" title="Link to this heading">¶</a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>PromQL</p></th>
<th class="head"><p>PPL</p></th>
<th class="head"><p>Remarks</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">avg_over_time(go_goroutines[5m])</span></code></p></td>
<td><p>source = promcatalog.<code class="docutils literal notranslate"><span class="pre">go_goroutines</span></code> | eval k = <code class="docutils literal notranslate"><span class="pre">avg_over_time</span></code>(&#64;value, 5m)</p></td>
<td><p>Average within each series over a 5-minute period:</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">max_over_time(process_resident_memory_bytes[1d])</span></code></p></td>
<td><p>source = promcatalog.<code class="docutils literal notranslate"><span class="pre">process_resident_memory_bytes</span></code> | eval k = <code class="docutils literal notranslate"><span class="pre">max_over_time</span></code>(&#64;value, 1d)</p></td>
<td><p>Get the maximum for each series over a one-day period:</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">count_over_time(process_resident_memory_bytes[5m])</span></code></p></td>
<td><p>source = promcatalog.<code class="docutils literal notranslate"><span class="pre">process_resident_memory_bytes</span></code> | eval k = <code class="docutils literal notranslate"><span class="pre">count_over_time</span></code>(&#64;value, 5m)</p></td>
<td><p>Count the number of samples for each series over a 5-minute period:</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="implementation">
<h2>7. Implementation<a class="headerlink" href="#implementation" title="Link to this heading">¶</a></h2>
<p>Tasks and Phase wise Division</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Goal</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Phase</p></th>
<th class="head"><p>Area</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Catalog Configuration for external Metric Datastore</p></td>
<td><p>Provides rudimentary way of capturing catalog connection information using opensearch-keystore.</p></td>
<td><p>P0</p></td>
<td><p>Backend (OS SQL Plugin)</p></td>
</tr>
<tr class="row-odd"><td><p>PPL Grammar to support basic prometheus metric operations.</p></td>
<td><p>This involes support of PPL commands search, stats, where commands on Prometheus Data</p></td>
<td><p>P0</p></td>
<td><p>Backend (OS SQL Plugin)</p></td>
</tr>
<tr class="row-even"><td><p>PromQL support</p></td>
<td><p>PromQL support for querying prometheus</p></td>
<td><p>P0</p></td>
<td><p>Backend (OS SQL Plugin)</p></td>
</tr>
<tr class="row-odd"><td><p>Event Analytic Page enhancements</p></td>
<td><p>This includes UI support in the existing event analytics page of for visualizations of metric data from Prometheus</p></td>
<td><p>P0</p></td>
<td><p>UI (OSD Observability Plugin)</p></td>
</tr>
<tr class="row-even"><td><p>PPL Grammar to support advanced prometheus metric operations.</p></td>
<td><p>This includes design and implementation of PPL grammar for advanced query operations like cross-metric commands, rate commands, histogram and summary commands.</p></td>
<td><p>P1</p></td>
<td><p>Backend (OS SQL Plugin)</p></td>
</tr>
<tr class="row-odd"><td><p>Metric analytics page</p></td>
<td><p>Build a new page explicitly for viewing metrics from all sources</p></td>
<td><p>P1</p></td>
<td><p>UI (OSD Observability Plugin)</p></td>
</tr>
</tbody>
</table>
<p>Quick Demo:</p>
<p>https://user-images.githubusercontent.com/99925918/164787195-86a17d34-cf75-4a40-943f-24d1cf7b9a51.mov</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">sql-docs</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, josh.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="../../_sources/docs/dev/datasource-prometheus.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>