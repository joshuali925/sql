<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Architecture &#8212; sql-docs  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=12dfc556" />
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>In a database engine, there are different ways to optimize query performance. For instance, rule-based/cost-based optimizer and distributed execution layer tries to find best execution plan by cost estimate and equivalent transformation of query plan. Here we’re proposing an alternative approach which is to accelerate query execution by materialized view for time-space tradeoff.</p>
<section id="architecture">
<h1>Architecture<a class="headerlink" href="#architecture" title="Link to this heading">¶</a></h1>
<p>Here is a reference architecture that illustrates components and the entire workflow which essentially is a <em>workload-driven feedback loop</em>:</p>
<ol class="arabic simple">
<li><p><em>Input</em>: Query plan telemetry collected</p></li>
<li><p><em>Generating feedback</em>: Feeding it into a workload-driven feedback generator</p></li>
<li><p><em>Output</em>: Feedback for optimizer to rewrite query plan in future</p></li>
</ol>
<p>Basically, <em>feedback</em> is referring to various materialized view prebuilt (either online or offline) which hints acceleration opportunity to query optimizer.</p>
<p><img alt="AutoMV (1) (1)" src="https://user-images.githubusercontent.com/46505291/168863085-d5d39ab4-40bf-41c8-922c-4a45572e40dd.png" /></p>
<p>There are 2 areas and paths moving forward for both of which lack open source solutions:</p>
<ul class="simple">
<li><p>OpenSearch engine acceleration: accelerate DSL or SQL/PPL engine execution</p></li>
<li><p>MPP/Data Lake engine acceleration: accelerate Spark, Presto, Trino</p></li>
</ul>
</section>
<section id="general-acceleration-workflow">
<h1>General Acceleration Workflow<a class="headerlink" href="#general-acceleration-workflow" title="Link to this heading">¶</a></h1>
<section id="workload-telemetry-collecting">
<h2>1.Workload Telemetry Collecting<a class="headerlink" href="#workload-telemetry-collecting" title="Link to this heading">¶</a></h2>
<p>Collect query plan telemetry generated in query execution and emit it as feedback generation input.</p>
<ul class="simple">
<li><p><em>Query Plan Telemetry:</em> Specifically, query plan telemetry means statistics collected on each physical node (sub-query or sub-expression) when execution. Generally, the statistics include input/output size, column cardinality, running time etc. Eventually logical plan is rewritten to reuse materialized view, so the statistics in execution may need to be linked to logical plan before emitting telemetry data.</p></li>
<li><p><em>Challenge:</em> Efforts required in this stage depends on to what extent the query engine is observable and how easy telemetry can be collected.</p></li>
</ul>
</section>
<section id="workload-telemetry-preprocessing">
<h2>2.Workload Telemetry Preprocessing<a class="headerlink" href="#workload-telemetry-preprocessing" title="Link to this heading">¶</a></h2>
<p>Preprocess query plan telemetry into uniform workload representation.</p>
<ul class="simple">
<li><p><em>Workload Representation</em>: uniform workload representation decouples subsequent stages from specific telemetry data format and store.</p></li>
</ul>
</section>
<section id="view-selection">
<h2>3.View Selection<a class="headerlink" href="#view-selection" title="Link to this heading">¶</a></h2>
<p>Analyze workload data and select sub-query as materialization candidate according to view selection algorithm.</p>
<ul class="simple">
<li><p><em>Algorithm</em></p>
<ul>
<li><p>View selection algorithm can be heuristic rule, such as estimate high performance boost and low materialization cost, or by more complex learning algorithm.</p></li>
<li><p>Alternatively the selection can be manually done by customers with access to all workload statistics.</p></li>
<li><p>In between is giving acceleration suggestion by advisor and allow customer intervene to change the default acceleration strategy.</p></li>
</ul>
</li>
<li><p><em>Select Timing</em></p>
<ul>
<li><p><em>Online:</em> analyze and select view candidate at query processing time which benefits interactive/ad-hoc queries</p></li>
<li><p><em>Offline:</em> shown as in figure above</p></li>
</ul>
</li>
<li><p><em>Challenge</em>: Automatic workload analysis and view selection is challenging and may require machine learning capability. Simple heuristic rules mentioned above may be acceptable. Alternative options include view recommendation advisor or manual selection by customers.</p></li>
</ul>
</section>
<section id="view-materialization-and-maintenance">
<h2>4.View Materialization and Maintenance<a class="headerlink" href="#view-materialization-and-maintenance" title="Link to this heading">¶</a></h2>
<p>Materialize selected view and maintain the consistency between source data and materialized view data, by incrementally refreshing for example.</p>
<ul class="simple">
<li><p><em>Materialized View:</em> is a database object that contains the results of a query. The result may be subset of a single table or multi-table join, or may be a summary using an aggregate function</p>
<ul>
<li><p><em>Query Result Cache</em></p>
<ul>
<li><p><em>Full Result</em>: MV that stores entire result set and can only be reused by same deterministic query</p></li>
<li><p><em>Intermediate Result</em>: MV that stores result for a subquery (similar as Covering Index if filtering operation only)</p></li>
</ul>
</li>
<li><p><em>Secondary Index</em></p>
<ul>
<li><p><em>Data Skipping Index</em>: MV that stores column statistics in coarse-grained way, Small Materialized Aggregate, and thus skip those impossible to produce a match. Common SMA includes Min-Max, Bloom Filter, Value List.</p></li>
<li><p><em>Covering Index</em>: MV that stores indexed column value(s) and included column value(s) so that index itself can answer the query and no need to access original data. Common index implementation includes B-tree family, Hash, Z-Ordering index.</p></li>
</ul>
</li>
<li><p><em>Approximate Data Structure</em></p></li>
</ul>
</li>
<li><p><em>Materialization Timing</em></p>
<ul>
<li><p><em>Ingestion Time:</em> for a view defined and materialized at ingestion time, it can be “registered” to Selected View table in figure above (ex. by DDL CREATE MV). In this way the query acceleration framework can take care of query plan optimization</p>
<ul>
<li><p>Parquet: min-max SMA</p></li>
<li><p>S3 query federation: user defined transformation as final resulting MV. More details in https://github.com/opensearch-project/sql/issues/595</p></li>
<li><p>Loki: labels as skipping hash index</p></li>
<li><p>DataSketch: approximate data structure</p></li>
</ul>
</li>
<li><p><em>Online (Query Processing Time):</em> add materialization overhead to first query in future</p></li>
<li><p><em>Offline:</em> shown as in figure above</p></li>
</ul>
</li>
<li><p><em>Challenge:</em> To ensure consistency, the materialized view needs to be in sync with source data. Without real-time notification to refresh or invalidate, hybrid scan or similar mechanism is required to reuse partial stale materialized view.</p></li>
</ul>
</section>
<section id="query-plan-optimization">
<h2>5.Query Plan Optimization<a class="headerlink" href="#query-plan-optimization" title="Link to this heading">¶</a></h2>
<p>At last, query optimizer checks the existing materialized view and replace original operator with scan on materialized view.</p>
<ul class="simple">
<li><p><em>View Matching:</em> match sub-query with materialized view</p></li>
<li><p><em>Query Rewrite:</em> replace query plan node with materialized view scan operator</p></li>
</ul>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">sql-docs</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, josh.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="../../_sources/docs/dev/query-automatic-acceleration.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>