<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Pagination in v2 Engine &#8212; Example 0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=12dfc556" />
    <script src="../_static/documentation_options.js?v=2709fde1"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="pagination-in-v2-engine">
<h1>Pagination in v2 Engine<a class="headerlink" href="#pagination-in-v2-engine" title="Link to this heading">¶</a></h1>
<p>Pagination allows a SQL plugin client to retrieve arbitrarily large results sets one subset at a time.</p>
<p>A cursor is a SQL abstraction for pagination. A client can open a cursor, retrieve a subset of data given a cursor and close a cursor.</p>
<p>Currently, SQL plugin does not provide SQL cursor syntax. However, the SQL REST endpoint can return result a page at a time. This feature is used by JDBC and ODBC drivers.</p>
</section>
<section id="scope">
<h1>Scope<a class="headerlink" href="#scope" title="Link to this heading">¶</a></h1>
<p>This document describes pagination in V2 sql engine for non-aggregate queries – queries
without <code class="docutils literal notranslate"><span class="pre">GROUP</span> <span class="pre">BY</span></code> clause or use of window functions.</p>
</section>
<section id="demo">
<h1>Demo<a class="headerlink" href="#demo" title="Link to this heading">¶</a></h1>
<p>https://user-images.githubusercontent.com/88679692/224208630-8d38d833-abf8-4035-8d15-d5fb4382deca.mp4</p>
</section>
<section id="rest-api">
<h1>REST API<a class="headerlink" href="#rest-api" title="Link to this heading">¶</a></h1>
<section id="initial-query-request">
<h2>Initial Query Request<a class="headerlink" href="#initial-query-request" title="Link to this heading">¶</a></h2>
<p>Initial query request contains the search request and page size. Search query to OpenSearch is built during processing of this request. Neither the query nor page size can be changed while scrolling through pages based on this request.
The only difference between paged and non-paged requests is <code class="docutils literal notranslate"><span class="pre">fetch_size</span></code> parameter supplied in paged request.</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="err">POST</span><span class="w"> </span><span class="err">/_plugi</span><span class="kc">ns</span><span class="err">/_sql</span>
<span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;query&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;...&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;fetch_size&quot;</span><span class="p">:</span><span class="w"> </span><span class="err">N</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Response:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;cursor&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;&lt;cursor_id&gt;&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;datarows&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="err">...</span>
<span class="w">  </span><span class="p">],</span>
<span class="w">  </span><span class="nt">&quot;schema&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="err">...</span>
<span class="w">  </span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">query</span></code> is a DQL statement. <code class="docutils literal notranslate"><span class="pre">fetch_size</span></code> is a positive integer, indicating number of rows to return in each page.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">query</span></code> is a DML statement then pagination does not apply, the <code class="docutils literal notranslate"><span class="pre">fetch_size</span></code> parameter is ignored and a cursor is not created. This is existing behaviour in v1 engine.</p>
<p>The client receives an <a class="reference internal" href="#error-response"><span class="xref myst">error response</span></a> if:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fetch_size</span></code> is not a positive integer</p></li>
<li><p>evaluating <code class="docutils literal notranslate"><span class="pre">query</span></code> results in a server-side error</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fetch_size</span></code> is bigger than <code class="docutils literal notranslate"><span class="pre">max_window_size</span></code> cluster-wide parameter.</p></li>
</ul>
</section>
<section id="subsequent-query-request">
<h2>Subsequent Query Request<a class="headerlink" href="#subsequent-query-request" title="Link to this heading">¶</a></h2>
<p>Subsequent query request contains a cursor only.</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="err">POST</span><span class="w"> </span><span class="err">/_plugi</span><span class="kc">ns</span><span class="err">/_sql</span>
<span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;cursor&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;&lt;cursor_id&gt;&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Similarly to v1 engine, the response object is the same as initial response if this is not the last page.</p>
<p><code class="docutils literal notranslate"><span class="pre">cursor_id</span></code> will be different with each request.</p>
</section>
<section id="end-of-scrolling-paging">
<h2>End of scrolling/paging<a class="headerlink" href="#end-of-scrolling-paging" title="Link to this heading">¶</a></h2>
<p>The last page in a response will not have a cursor id property.</p>
</section>
<section id="cursor-keep-alive-timeout">
<h2>Cursor Keep Alive Timeout<a class="headerlink" href="#cursor-keep-alive-timeout" title="Link to this heading">¶</a></h2>
<p>Each cursor has a keep alive timer associated with it. When the timer runs out, the cursor is automatically closed by OpenSearch.</p>
<p>This timer is reset every time a page is retrieved.</p>
<p>The client will receive an <a class="reference internal" href="#error-response"><span class="xref myst">error response</span></a> if it sends a cursor request for an expired cursor.</p>
<p>Keep alive timeout is <a class="reference internal" href="../user/admin/settings.html#plugins.sql.cursor.keep_alive"><span class="std std-ref">configurable</span></a> by setting <code class="docutils literal notranslate"><span class="pre">plugins.sql.cursor.keep_alive</span></code> and has default value of 1 minute.</p>
</section>
<section id="error-response">
<h2>Error Response<a class="headerlink" href="#error-response" title="Link to this heading">¶</a></h2>
<p>The client will receive an error response if any of the above REST calls result in a server-side error.</p>
<p>The response object has the following format:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;error&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nt">&quot;details&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;&lt;string&gt;&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;reason&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;&lt;string&gt;&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;&lt;string&gt;&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="nt">&quot;status&quot;</span><span class="p">:</span><span class="w"> </span><span class="err">&lt;i</span><span class="kc">nte</span><span class="err">ger&gt;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">details</span></code>, <code class="docutils literal notranslate"><span class="pre">reason</span></code>, and <code class="docutils literal notranslate"><span class="pre">type</span></code> properties are string values. The exact values will depend on the error state encountered.
<code class="docutils literal notranslate"><span class="pre">status</span></code> is an HTTP status code</p>
</section>
<section id="opensearch-data-retrieval-strategy">
<h2>OpenSearch Data Retrieval Strategy<a class="headerlink" href="#opensearch-data-retrieval-strategy" title="Link to this heading">¶</a></h2>
<p>OpenSearch provides several data retrieval APIs that are optimized for different use cases.</p>
<p>At this time, SQL plugin uses simple search API and scroll API.</p>
<p>Simple retrieval API returns at most <code class="docutils literal notranslate"><span class="pre">max_result_window</span></code> number of documents.  <code class="docutils literal notranslate"><span class="pre">max_result_window</span></code> is an index setting.</p>
<p>Scroll API requests returns all documents but can incur high memory costs on OpenSearch coordination node.</p>
<p>Efficient implementation of pagination needs to be aware of retrieval API used. Each retrieval strategy will be considered separately.</p>
<p>The discussion below uses <em>under max_result_window</em> to refer to scenarios that can be implemented with simple retrieval API and <em>over max_result_window</em> for scenarios that require scroll API to implement.</p>
</section>
<section id="sql-node-load-balancing">
<h2>SQL Node Load Balancing<a class="headerlink" href="#sql-node-load-balancing" title="Link to this heading">¶</a></h2>
<p>V2 SQL engine supports <em>sql node load balancing</em> — a cursor request can be routed to any SQL node in a cluster. This is achieved by encoding all data necessary to retrieve the next page in the <code class="docutils literal notranslate"><span class="pre">cursor_id</span></code> property in the response.</p>
</section>
<section id="feature-design">
<h2>Feature Design<a class="headerlink" href="#feature-design" title="Link to this heading">¶</a></h2>
<p>To support pagination, v2 SQL engine needs to:</p>
<ol class="arabic simple">
<li><p>in REST front-end:</p>
<ol class="arabic simple">
<li><p>Route supported paginated query to v2 engine for</p>
<ol class="arabic simple">
<li><p>Initial requests,</p></li>
<li><p>Next page requests.</p></li>
</ol>
</li>
<li><p>Fallback to v1 engine for queries not supported by v2 engine.</p></li>
<li><p>Create correct JSON response from execution of paginated physical plan by v2 engine.</p></li>
</ol>
</li>
<li><p>during query planning:</p>
<ol class="arabic simple">
<li><p>Differentiate between paginated and normal query plans.</p></li>
<li><p>Push down pagination to table scan.</p></li>
<li><p>Create a physical query plan from a cursor id.</p></li>
</ol>
</li>
<li><p>during query execution:</p>
<ol class="arabic simple">
<li><p>Serialize an executing query and generate a cursor id after returning <code class="docutils literal notranslate"><span class="pre">fetch_size</span></code> number of elements.</p></li>
</ol>
</li>
<li><p>in OpenSearch data source:</p>
<ol class="arabic simple">
<li><p>Support pagination push down.</p></li>
<li><p>Support other push down optimizations with pagination.</p></li>
</ol>
</li>
</ol>
<section id="query-plan-changes">
<h3>Query Plan Changes<a class="headerlink" href="#query-plan-changes" title="Link to this heading">¶</a></h3>
<p>All three kinds of query requests — non-paged, initial page, or subsequent page  — are processed in the same way. Simplified workflow of query plan processing is shown below for reference.</p>
<div class="highlight-mermaid notranslate"><div class="highlight"><pre><span></span>stateDiagram-v2
  state &quot;Request&quot; as NonPaged {
    direction LR
    state &quot;Parse Tree&quot; as Parse
    state &quot;Unresolved Query Plan&quot; as Unresolved
    state &quot;Abstract Query Plan&quot; as Abstract
    state &quot;Logical Query Plan&quot; as Logical
    state &quot;Optimized Query Plan&quot; as Optimized
    state &quot;Physical Query Plan&quot; as Physical

    [*] --&gt; Parse : ANTLR
    Parse --&gt; Unresolved : AstBuilder
    Unresolved --&gt; Abstract : QueryPlanner
    Abstract --&gt; Logical : Planner
    Logical --&gt; Optimized : Optimizer
    Optimized --&gt; Physical : Implementor
  }
</pre></div>
</div>
<section id="unresolved-query-plan">
<h4>Unresolved Query Plan<a class="headerlink" href="#unresolved-query-plan" title="Link to this heading">¶</a></h4>
<p>Unresolved Query Plan for non-paged requests remains unchanged.</p>
<p>To support initial query requests, the <code class="docutils literal notranslate"><span class="pre">QueryPlan</span></code> class has a new optional field <code class="docutils literal notranslate"><span class="pre">pageSize</span></code>.</p>
<div class="highlight-mermaid notranslate"><div class="highlight"><pre><span></span>classDiagram
  direction LR
  class QueryPlan {
    &lt;&lt;AbstractPlan&gt;&gt;
    -Optional~int~ pageSize
    -UnresolvedPlan plan
    -QueryService queryService
  }
  class UnresolvedQueryPlan {
    &lt;&lt;UnresolvedPlan&gt;&gt;
  }
  QueryPlan --* UnresolvedQueryPlan
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">QueryPlanFactory.create</span></code> is passed initial query request, it:</p>
<ol class="arabic simple">
<li><p>Adds an instance of <code class="docutils literal notranslate"><span class="pre">Paginate</span></code> unresolved plan as the root of the unresolved query plan.</p></li>
<li><p>Sets <code class="docutils literal notranslate"><span class="pre">pageSize</span></code> parameter in <code class="docutils literal notranslate"><span class="pre">QueryPlan</span></code>.</p></li>
</ol>
<div class="highlight-mermaid notranslate"><div class="highlight"><pre><span></span>classDiagram
  direction LR
  class QueryPlan {
    &lt;&lt;AbstractPlan&gt;&gt;
    -Optional~int~ pageSize
    -UnresolvedPlan plan
    -QueryService queryService
  }
  class Paginate {
    &lt;&lt;UnresolvedPlan&gt;&gt;
    -int pageSize
    -UnresolvedPlan child
  }
  class UnresolvedQueryPlan {
    &lt;&lt;UnresolvedPlan&gt;&gt;
  }
  QueryPlan --* Paginate
  Paginate --* UnresolvedQueryPlan
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">QueryPlanFactory.create</span></code> is passed a subsequent query request, it:</p>
<ol class="arabic simple">
<li><p>Creates an instance of <code class="docutils literal notranslate"><span class="pre">FetchCursor</span></code> unresolved plan as the sole node in the unresolved query plan.</p></li>
</ol>
<div class="highlight-mermaid notranslate"><div class="highlight"><pre><span></span>classDiagram
    direction LR
    class QueryPlan {
        &lt;&lt;AbstractPlan&gt;&gt;
        -Optional~int~ pageSize
        -UnresolvedPlan plan
        -QueryService queryService
    }
    class FetchCursor {
        &lt;&lt;UnresolvedPlan&gt;&gt;
        -String cursorId
    }
    QueryPlan --* FetchCursor
</pre></div>
</div>
<p>The examples below show Abstract Query Plan for the same query in different request types:</p>
<div class="highlight-mermaid notranslate"><div class="highlight"><pre><span></span>stateDiagram-v2
  state &quot;Non Paged Request&quot; as NonPaged {
    state &quot;QueryPlan&quot; as QueryPlanNP
    state &quot;Project&quot; as ProjectNP
    state &quot;Limit&quot; as LimitNP
    state &quot;Filter&quot; as FilterNP
    state &quot;Aggregation&quot; as AggregationNP
    state &quot;Relation&quot; as RelationNP

    QueryPlanNP --&gt; ProjectNP
    ProjectNP --&gt; LimitNP
    LimitNP --&gt; FilterNP
    FilterNP --&gt; AggregationNP
    AggregationNP --&gt; RelationNP
  }

  state &quot;Initial Query Request&quot; as Paged {
    state &quot;QueryPlan&quot; as QueryPlanIP
    state &quot;Project&quot; as ProjectIP
    state &quot;Limit&quot; as LimitIP
    state &quot;Filter&quot; as FilterIP
    state &quot;Aggregation&quot; as AggregationIP
    state &quot;Relation&quot; as RelationIP

    Paginate --&gt; QueryPlanIP
    QueryPlanIP --&gt; ProjectIP
    ProjectIP --&gt; LimitIP
    LimitIP --&gt; FilterIP
    FilterIP --&gt; AggregationIP
    AggregationIP --&gt; RelationIP
  }

  state &quot;Subsequent Query Request&quot; As Sub {
    FetchCursor
  }
</pre></div>
</div>
</section>
<section id="logical-query-plan">
<h4>Logical Query Plan<a class="headerlink" href="#logical-query-plan" title="Link to this heading">¶</a></h4>
<p>There are no changes for non-paging requests.</p>
<p>Changes to logical query plan to support Initial Query Request:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">LogicalPaginate</span></code> is added to the top of the tree. It stores information about paging should be done in a private field <code class="docutils literal notranslate"><span class="pre">pageSize</span></code> being pushed down in the <code class="docutils literal notranslate"><span class="pre">Optimizer</span></code>.</p></li>
</ol>
<div class="highlight-mermaid notranslate"><div class="highlight"><pre><span></span>classDiagram
  direction LR
  class LogicalPaginate {
    &lt;&lt;LogicalPlan&gt;&gt;
    int pageSize
  }
  class LogicalQueryPlan {
    &lt;&lt;LogicalPlan&gt;&gt;
  }
  class LogicalRelation {
    &lt;&lt;LogicalPlan&gt;&gt;
  }
  LogicalPaginate --* LogicalQueryPlan
  LogicalQueryPlan --* LogicalRelation
</pre></div>
</div>
<p>For subsequent page requests, <code class="docutils literal notranslate"><span class="pre">FetchCursor</span></code> unresolved plan is mapped to <code class="docutils literal notranslate"><span class="pre">LogicalFetchCursor</span></code> logical plan.</p>
<div class="highlight-mermaid notranslate"><div class="highlight"><pre><span></span>classDiagram
  direction LR
  class LogicalQueryPlan {
    &lt;&lt;LogicalPlan&gt;&gt;
  }
  class LogicalFetchCursor {
    &lt;&lt;LogicalPlan&gt;&gt;
    -String cursorId
  }
  LogicalQueryPlan --* LogicalFetchCursor
</pre></div>
</div>
<p>The examples below show logical query plan for the same query in different request types:</p>
<div class="highlight-mermaid notranslate"><div class="highlight"><pre><span></span>stateDiagram-v2
  state &quot;Non Paged Request&quot; as NonPaged {
    state &quot;LogicalProject&quot; as ProjectNP
    state &quot;LogicalLimit&quot; as LimitNP
    state &quot;LogicalFilter&quot; as FilterNP
    state &quot;LogicalAggregation&quot; as AggregationNP
    state &quot;LogicalRelation&quot; as RelationNP

    ProjectNP --&gt; LimitNP
    LimitNP --&gt; FilterNP
    FilterNP --&gt; AggregationNP
    AggregationNP --&gt; RelationNP
  }

  state &quot;Initial Query Request&quot; as Paged {
    state &quot;LogicalProject&quot; as ProjectIP
    state &quot;LogicalLimit&quot; as LimitIP
    state &quot;LogicalFilter&quot; as FilterIP
    state &quot;LogicalAggregation&quot; as AggregationIP
    state &quot;LogicalRelation&quot; as RelationIP

    LogicalPaginate --&gt; ProjectIP
    ProjectIP --&gt; LimitIP
    LimitIP --&gt; FilterIP
    FilterIP --&gt; AggregationIP
    AggregationIP --&gt; RelationIP
  }

  state &quot;Subsequent Query Request&quot; As Sub {
    FetchCursor
  }
</pre></div>
</div>
</section>
<section id="optimized-logical-query-plan">
<h4>Optimized Logical Query Plan<a class="headerlink" href="#optimized-logical-query-plan" title="Link to this heading">¶</a></h4>
<p>Pagination is implemented by push down to OpenSearch. The following is only relevant for
initial paged requests. Non-paged request optimization was not changed and there is no optimization
to be done for subsequent page query plans.</p>
<p>Push down logical is implemented in  <code class="docutils literal notranslate"><span class="pre">OpenSearchIndexScanQueryBuilder.pushDownPageSize</span></code> method.
This method is called by <code class="docutils literal notranslate"><span class="pre">PushDownPageSize</span></code> rule during plan optimization.  <code class="docutils literal notranslate"><span class="pre">LogicalPaginate</span></code> is removed from the query plan during push down operation in <code class="docutils literal notranslate"><span class="pre">Optimizer</span></code>.</p>
<p>See <a class="reference internal" href="query-optimizer-improvement.html#TableScanBuilder"><span class="std std-ref">article about <code class="docutils literal notranslate"><span class="pre">TableScanBuilder</span></code></span></a> for more details.</p>
<p>The examples below show optimized Logical Query Plan for the same query in different request types:</p>
<div class="highlight-mermaid notranslate"><div class="highlight"><pre><span></span>stateDiagram-v2
  state &quot;Non Paged Request&quot; as NonPaged {
    state &quot;LogicalProject&quot; as ProjectNP
    state &quot;LogicalLimit&quot; as LimitNP
    state &quot;LogicalSort&quot; as SortNP
    state &quot;OpenSearchIndexScanQueryBuilder&quot; as RelationNP

    ProjectNP --&gt; LimitNP
    LimitNP --&gt; SortNP
    SortNP --&gt; RelationNP
  }

</pre></div>
</div>
</section>
<section id="physical-query-plan-and-execution">
<h4>Physical Query Plan and Execution<a class="headerlink" href="#physical-query-plan-and-execution" title="Link to this heading">¶</a></h4>
<p>Changes:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">OpenSearchIndexScanBuilder</span></code> is converted to <code class="docutils literal notranslate"><span class="pre">OpenSearchIndexScan</span></code> by <code class="docutils literal notranslate"><span class="pre">Implementor</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LogicalPlan.pageSize</span></code> is mapped to <code class="docutils literal notranslate"><span class="pre">OpenSearchIndexScan.maxResponseSize</span></code>. This is the limit to  the number of elements in a response.</p></li>
<li><p>Entire Physical Query Plan is created by <code class="docutils literal notranslate"><span class="pre">PlanSerializer</span></code> for Subsequent Query requests. The deserialized plan has the same structure as the Initial Query Request.</p></li>
<li><p>Implemented serialization and deserialization for <code class="docutils literal notranslate"><span class="pre">OpenSearchScrollRequest</span></code>.</p></li>
</ol>
<p>The examples below show physical query plan for the same query in different request types:</p>
<div class="highlight-mermaid notranslate"><div class="highlight"><pre><span></span>stateDiagram-v2
  state &quot;Non Paged Request&quot; as NonPaged {
    state &quot;ProjectOperator&quot; as ProjectNP
    state &quot;LimitOperator&quot; as LimitNP
    state &quot;SortOperator&quot; as SortNP
    state &quot;OpenSearchIndexScan&quot; as RelationNP
    state &quot;OpenSearchQueryRequest&quot; as QRequestNP

    ProjectNP --&gt; LimitNP
    LimitNP --&gt; SortNP
    SortNP --&gt; RelationNP
    RelationNP --&gt; QRequestNP
  }

  state &quot;Initial Query Request&quot; as Paged {
    state &quot;ProjectOperator&quot; as ProjectIP
    state &quot;LimitOperator&quot; as LimitIP
    state &quot;SortOperator&quot; as SortIP
    state &quot;OpenSearchIndexScan&quot; as RelationIP
    state &quot;OpenSearchQueryRequest&quot; as QRequestIP

    ProjectIP --&gt; LimitIP
    LimitIP --&gt; SortIP
    SortIP --&gt; RelationIP
    RelationIP --&gt; QRequestIP
  }

  state &quot;Subsequent Query Request&quot; As Sub {
    state &quot;ProjectOperator&quot; as ProjectSP
    state &quot;LimitOperator&quot; as LimitSP
    state &quot;SortOperator&quot; as SortSP
    state &quot;OpenSearchIndexScan&quot; as RelationSP
    state &quot;OpenSearchScrollRequest&quot; as RequestSP

    ProjectSP --&gt; LimitSP
    LimitSP --&gt; SortSP
    SortSP --&gt; RelationSP
    RelationSP --&gt; RequestSP
  }
</pre></div>
</div>
</section>
</section>
<section id="architecture-diagrams">
<h3>Architecture Diagrams<a class="headerlink" href="#architecture-diagrams" title="Link to this heading">¶</a></h3>
<p>New code workflows which added by Pagination feature are highlighted.</p>
<section id="non-paging-query-request">
<h4>Non Paging Query Request<a class="headerlink" href="#non-paging-query-request" title="Link to this heading">¶</a></h4>
<p>A non-paging request sequence diagram is shown below for comparison:</p>
<div class="highlight-mermaid notranslate"><div class="highlight"><pre><span></span>sequenceDiagram
    participant SQLService
    participant QueryPlanFactory
    participant QueryService
    participant Planner
    participant CreateTableScanBuilder
    participant OpenSearchExecutionEngine

SQLService -&gt;&gt;+ QueryPlanFactory: execute
  QueryPlanFactory -&gt;&gt;+ QueryService: execute
    QueryService -&gt;&gt;+ Planner: optimize
      Planner -&gt;&gt;+ CreateTableScanBuilder: apply
        CreateTableScanBuilder --&gt;&gt;- Planner: index scan
      Planner --&gt;&gt;- QueryService: Logical Query Plan
    QueryService -&gt;&gt;+ OpenSearchExecutionEngine: execute
      OpenSearchExecutionEngine --&gt;&gt;- QueryService: execution completed
    QueryService --&gt;&gt;- QueryPlanFactory: execution completed
  QueryPlanFactory --&gt;&gt;- SQLService: execution completed
</pre></div>
</div>
</section>
<section id="id1">
<h4>Initial Query Request<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h4>
<p>Processing of an Initial Query Request has few extra steps comparing versus processing a regular Query Request:</p>
<ol class="arabic simple">
<li><p>Query validation with <code class="docutils literal notranslate"><span class="pre">CanPaginateVisitor</span></code>. This is required to validate whether incoming query can be paged. This also activate legacy engine fallback mechanism.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Serialization</span></code> is performed by <code class="docutils literal notranslate"><span class="pre">PlanSerializer</span></code> - it converts Physical Plan Tree into a cursor, which could be used query a next page.</p></li>
</ol>
<div class="highlight-mermaid notranslate"><div class="highlight"><pre><span></span>sequenceDiagram
    participant SQLService
    participant QueryPlanFactory
    participant CanPaginateVisitor
    participant QueryService
    participant Planner
    participant CreatePagingScanBuilder
    participant OpenSearchExecutionEngine
    participant PlanSerializer

SQLService -&gt;&gt;+ QueryPlanFactory : execute
  rect rgb(91, 123, 155)
  QueryPlanFactory -&gt;&gt;+ CanPaginateVisitor : canConvertToCursor
    CanPaginateVisitor --&gt;&gt;- QueryPlanFactory : true
  end
  QueryPlanFactory -&gt;&gt;+ QueryService : execute
    QueryService -&gt;&gt;+ Planner : optimize
      rect rgb(91, 123, 155)
      Planner -&gt;&gt;+ CreateTableScanBuilder : apply
        CreateTableScanBuilder --&gt;&gt;- Planner : paged index scan
      end
      Planner --&gt;&gt;- QueryService : Logical Query Plan
    QueryService -&gt;&gt;+ OpenSearchExecutionEngine : execute
      rect rgb(91, 123, 155)
      Note over OpenSearchExecutionEngine, PlanSerializer : Serialization
      OpenSearchExecutionEngine -&gt;&gt;+ PlanSerializer : convertToCursor
        PlanSerializer --&gt;&gt;- OpenSearchExecutionEngine : cursor
      end
      OpenSearchExecutionEngine --&gt;&gt;- QueryService : execution completed
    QueryService --&gt;&gt;- QueryPlanFactory : execution completed
  QueryPlanFactory --&gt;&gt;- SQLService : execution completed
</pre></div>
</div>
</section>
<section id="id2">
<h4>Subsequent Query Request<a class="headerlink" href="#id2" title="Link to this heading">¶</a></h4>
<p>Subsequent pages are processed by a new workflow. The key point there:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Deserialization</span></code> is performed by <code class="docutils literal notranslate"><span class="pre">PlanSerializer</span></code> to restore entire Physical Plan Tree encoded into the cursor.</p></li>
<li><p>Since query already contains the Physical Plan Tree, all tree processing steps are skipped.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Serialization</span></code> is performed by <code class="docutils literal notranslate"><span class="pre">PlanSerializer</span></code> - it converts Physical Plan Tree into a cursor, which could be used query a next page.</p></li>
</ol>
<div class="highlight-mermaid notranslate"><div class="highlight"><pre><span></span>sequenceDiagram
    participant QueryPlanFactory
    participant QueryService
    participant Analyzer
    participant Planner
    participant DefaultImplementor
    participant PlanSerializer
    participant OpenSearchExecutionEngine

QueryPlanFactory -&gt;&gt;+ QueryService : execute
  QueryService -&gt;&gt;+ Analyzer : analyze
    Analyzer --&gt;&gt;- QueryService : new LogicalFetchCursor
  QueryService -&gt;&gt;+ Planner : plan
    Planner -&gt;&gt;+ DefaultImplementor : implement
      rect rgb(91, 123, 155)
      DefaultImplementor -&gt;&gt;+ PlanSerializer : deserialize
        PlanSerializer --&gt;&gt;- DefaultImplementor: physical query plan
      end
      DefaultImplementor --&gt;&gt;- Planner : physical query plan
    Planner --&gt;&gt;- QueryService : physical query plan
  QueryService -&gt;&gt;+ OpenSearchExecutionEngine : execute
    OpenSearchExecutionEngine --&gt;&gt;- QueryService: execution completed
  QueryService --&gt;&gt;- QueryPlanFactory : execution completed
</pre></div>
</div>
</section>
<section id="legacy-engine-fallback">
<h4>Legacy Engine Fallback<a class="headerlink" href="#legacy-engine-fallback" title="Link to this heading">¶</a></h4>
<p>Since pagination in V2 engine supports fewer SQL commands than pagination in legacy engine, a fallback mechanism is created to keep V1 engine features still available for the end user. Pagination fallback is backed by a new exception type which allows legacy engine to intersect execution of a request.</p>
<div class="highlight-mermaid notranslate"><div class="highlight"><pre><span></span>sequenceDiagram
    participant RestSQLQueryAction
    participant Legacy Engine
    participant SQLService
    participant QueryPlanFactory
    participant CanPaginateVisitor

RestSQLQueryAction -&gt;&gt;+ SQLService : prepareRequest
  SQLService -&gt;&gt;+ QueryPlanFactory : execute
    rect rgb(91, 123, 155)
    note over SQLService, CanPaginateVisitor : V2 support check
    QueryPlanFactory -&gt;&gt;+ CanPaginateVisitor : canConvertToCursor
      CanPaginateVisitor --&gt;&gt;- QueryPlanFactory : false
    QueryPlanFactory --&gt;&gt;- RestSQLQueryAction : UnsupportedCursorRequestException
    deactivate SQLService
    end
      RestSQLQueryAction -&gt;&gt; Legacy Engine: accept
      Note over Legacy Engine : Processing in Legacy engine
        Legacy Engine --&gt;&gt; RestSQLQueryAction : complete
</pre></div>
</div>
</section>
<section id="serialization-and-deserialization-round-trip">
<h4>Serialization and Deserialization round trip<a class="headerlink" href="#serialization-and-deserialization-round-trip" title="Link to this heading">¶</a></h4>
<p>The SQL engine should be able to completely recover the Physical Query Plan to continue its execution to get the next page. Serialization mechanism is responsible for recovering the query plan. note: <code class="docutils literal notranslate"><span class="pre">ResourceMonitorPlan</span></code> isn’t serialized, because a new object of this type would be created for the restored query plan before execution.
Serialization and Deserialization are performed by Java object serialization API.</p>
<div class="highlight-mermaid notranslate"><div class="highlight"><pre><span></span>stateDiagram-v2
    direction LR
    state &quot;Initial Query Request Query Plan&quot; as FirstPage
    state FirstPage {
        state &quot;ProjectOperator&quot; as logState1_1
        state &quot;...&quot; as logState1_2
        state &quot;ResourceMonitorPlan&quot; as logState1_3
        state &quot;OpenSearchIndexScan&quot; as logState1_4
        state &quot;OpenSearchScrollRequest&quot; as logState1_5
        logState1_1 --&gt; logState1_2
        logState1_2 --&gt; logState1_3
        logState1_3 --&gt; logState1_4
        logState1_4 --&gt; logState1_5
    }

    state &quot;Deserialized Query Plan&quot; as SecondPageTree
    state SecondPageTree {
        state &quot;ProjectOperator&quot; as logState2_1
        state &quot;...&quot; as logState2_2
        state &quot;OpenSearchIndexScan&quot; as logState2_3
        state &quot;OpenSearchScrollRequest&quot; as logState2_4
        logState2_1 --&gt; logState2_2
        logState2_2 --&gt; logState2_3
        logState2_3 --&gt; logState2_4
    }

    state &quot;Subsequent Query Request Query Plan&quot; as SecondPage
    state SecondPage {
        state &quot;ProjectOperator&quot; as logState3_1
        state &quot;...&quot; as logState3_2
        state &quot;ResourceMonitorPlan&quot; as logState3_3
        state &quot;OpenSearchIndexScan&quot; as logState3_4
        state &quot;OpenSearchScrollRequest&quot; as logState3_5
        logState3_1 --&gt; logState3_2
        logState3_2 --&gt; logState3_3
        logState3_3 --&gt; logState3_4
        logState3_4 --&gt; logState3_5
    }

  FirstPage --&gt; SecondPageTree : Serialization and\nDeserialization
  SecondPageTree --&gt; SecondPage : Execution\nPreparation
</pre></div>
</div>
</section>
<section id="serialization">
<h4>Serialization<a class="headerlink" href="#serialization" title="Link to this heading">¶</a></h4>
<p>All query plan nodes which are supported by pagination should implement <a class="reference external" href="https://github.com/opensearch-project/sql/blob/f40bb6d68241e76728737d88026e4c8b1e6b3b8b/core/src/main/java/org/opensearch/sql/planner/SerializablePlan.java"><code class="docutils literal notranslate"><span class="pre">SerializablePlan</span></code></a> interface. <code class="docutils literal notranslate"><span class="pre">getPlanForSerialization</span></code> method of this interface allows serialization mechanism to skip a tree node from serialization. OpenSearch search request objects are not serialized, but search context provided by the OpenSearch cluster is extracted from them.</p>
<div class="highlight-mermaid notranslate"><div class="highlight"><pre><span></span>sequenceDiagram
    participant PlanSerializer
    participant ProjectOperator
    participant ResourceMonitorPlan
    participant OpenSearchIndexScan
    participant OpenSearchScrollRequest

PlanSerializer -&gt;&gt;+ ProjectOperator : getPlanForSerialization
  ProjectOperator --&gt;&gt;- PlanSerializer : this
PlanSerializer -&gt;&gt;+ ProjectOperator : serialize
  Note over ProjectOperator : dump private fields
  ProjectOperator -&gt;&gt;+ ResourceMonitorPlan : getPlanForSerialization
    ResourceMonitorPlan --&gt;&gt;- ProjectOperator : delegate
  Note over ResourceMonitorPlan : ResourceMonitorPlan&lt;br /&gt;is not serialized
  ProjectOperator -&gt;&gt;+ OpenSearchIndexScan : writeExternal
    OpenSearchIndexScan -&gt;&gt;+ OpenSearchScrollRequest : writeTo
      Note over OpenSearchScrollRequest : dump private fields
      OpenSearchScrollRequest --&gt;&gt;- OpenSearchIndexScan : serialized request
    Note over OpenSearchIndexScan : dump private fields
    OpenSearchIndexScan --&gt;&gt;- ProjectOperator : serialized
  ProjectOperator --&gt;&gt;- PlanSerializer : serialized
Note over PlanSerializer : Zip to reduce size
</pre></div>
</div>
</section>
<section id="deserialization">
<h4>Deserialization<a class="headerlink" href="#deserialization" title="Link to this heading">¶</a></h4>
<p>Deserialization restores previously serialized Physical Query Plan. The recovered plan is ready to execute and returns the next page of the search response. To complete the query plan restoration, SQL engine will build a new request to the OpenSearch node. This request doesn’t contain a search query, but it contains a search context reference — <code class="docutils literal notranslate"><span class="pre">scrollID</span></code>. To create a new <code class="docutils literal notranslate"><span class="pre">OpenSearchScrollRequest</span></code> object it requires access to the instance of <code class="docutils literal notranslate"><span class="pre">OpenSearchStorageEngine</span></code>. Note: <code class="docutils literal notranslate"><span class="pre">OpenSearchStorageEngine</span></code> can’t be serialized, and it exists as a singleton in the SQL plugin engine. <code class="docutils literal notranslate"><span class="pre">PlanSerializer</span></code> creates a customized deserialization binary object stream — <code class="docutils literal notranslate"><span class="pre">CursorDeserializationStream</span></code>. This stream provides an interface to access the <code class="docutils literal notranslate"><span class="pre">OpenSearchStorageEngine</span></code> object.</p>
<div class="highlight-mermaid notranslate"><div class="highlight"><pre><span></span>sequenceDiagram
    participant PlanSerializer
    participant CursorDeserializationStream
    participant ProjectOperator
    participant OpenSearchIndexScan
    participant OpenSearchScrollRequest

Note over PlanSerializer : Unzip
Note over PlanSerializer : Validate cursor integrity
PlanSerializer -&gt;&gt;+ CursorDeserializationStream : deserialize
  CursorDeserializationStream -&gt;&gt;+ ProjectOperator : create new
    Note over ProjectOperator: load private fields
    ProjectOperator --&gt;&gt; CursorDeserializationStream : deserialize input
  activate CursorDeserializationStream
  CursorDeserializationStream -&gt;&gt;+ OpenSearchIndexScan : create new
  deactivate CursorDeserializationStream
    OpenSearchIndexScan --&gt;&gt;+ CursorDeserializationStream : resolve engine
  CursorDeserializationStream -&gt;&gt;- OpenSearchIndexScan : OpenSearchStorageEngine
    Note over OpenSearchIndexScan : load private fields
    OpenSearchIndexScan -&gt;&gt;+ OpenSearchScrollRequest : create new
      OpenSearchScrollRequest --&gt;&gt;- OpenSearchIndexScan : created
    OpenSearchIndexScan --&gt;&gt;- ProjectOperator : deserialized
  ProjectOperator --&gt;&gt;- PlanSerializer : deserialized
  deactivate CursorDeserializationStream
</pre></div>
</div>
</section>
<section id="close-cursor">
<h4>Close Cursor<a class="headerlink" href="#close-cursor" title="Link to this heading">¶</a></h4>
<p>A user can forcibly close a cursor (scroll) at any moment of paging. Automatic close occurs when paging is complete and no more results left.
Close cursor protocol defined by following:</p>
<ol class="arabic simple">
<li><p>REST endpoint: <code class="docutils literal notranslate"><span class="pre">/_plugins/_sql/close</span></code></p></li>
<li><p>Request type: <code class="docutils literal notranslate"><span class="pre">POST</span></code></p></li>
<li><p>Request format:</p></li>
</ol>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;cursor&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;&lt;cursor&gt;&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<ol class="arabic simple" start="4">
<li><p>Response format:</p></li>
</ol>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;succeeded&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span>
<span class="p">}</span>
</pre></div>
</div>
<ol class="arabic simple" start="5">
<li><p>Failure or error: <a class="reference internal" href="#error-response"><span class="xref myst">error response</span></a></p></li>
<li><p>Use or sequential close of already closed cursor produces the same error as use of expired/auto-closed/non-existing cursor.</p></li>
</ol>
<div class="highlight-mermaid notranslate"><div class="highlight"><pre><span></span>sequenceDiagram
SQLService -&gt;&gt;+ QueryPlanFactory : execute
  QueryPlanFactory -&gt;&gt;+ QueryService : execute
  QueryService -&gt;&gt;+ Analyzer : analyze
  Analyzer --&gt;&gt;- QueryService : new LogicalCloseCursor
  QueryService -&gt;&gt;+ Planner : plan
  Planner -&gt;&gt;+ DefaultImplementor : implement
  DefaultImplementor -&gt;&gt;+ PlanSerializer : deserialize
  PlanSerializer --&gt;&gt;- DefaultImplementor: physical query plan
  DefaultImplementor --&gt;&gt;- Planner : new CloseOperator
  Planner --&gt;&gt;- QueryService : CloseOperator
  QueryService -&gt;&gt;+ OpenSearchExecutionEngine : execute
  Note over OpenSearchExecutionEngine : Open is no-op, no request issued,&lt;br /&gt;no results received and processed
  Note over OpenSearchExecutionEngine : Clean-up (clear scroll) on auto-close
  OpenSearchExecutionEngine --&gt;&gt;- QueryService: execution completed
  QueryService --&gt;&gt;- QueryPlanFactory : execution completed
  QueryPlanFactory --&gt;&gt;- SQLService : execution completed
</pre></div>
</div>
<div class="highlight-mermaid notranslate"><div class="highlight"><pre><span></span>stateDiagram-v2
    direction LR
    state &quot;Abstract Query Plan&quot; as Abstract {
      state &quot;CommandPlan&quot; as CommandPlan {
        state &quot;Unresolved Query Plan&quot; as Unresolved {
          state &quot;CloseCursor&quot; as CloseCursor
          state &quot;FetchCursor&quot; as FetchCursor

          CloseCursor --&gt; FetchCursor
        }
      }
    }
    state &quot;Logical Query Plan&quot; as Logical {
      state &quot;LogicalCloseCursor&quot; as LogicalCloseCursor
      state &quot;LogicalFetchCursor&quot; as LogicalFetchCursor

      LogicalCloseCursor --&gt; LogicalFetchCursor
    }
    state &quot;Optimized Query Plan&quot; as Optimized {
      state &quot;LogicalCloseCursor&quot; as LogicalCloseCursorO
      state &quot;LogicalFetchCursor&quot; as LogicalFetchCursorO

      LogicalCloseCursorO --&gt; LogicalFetchCursorO
    }
    state &quot;Physical Query Plan&quot; as Physical {
      state &quot;CursorCloseOperator&quot; as CursorCloseOperator
      state &quot;ProjectOperator&quot; as ProjectOperator
      state &quot;...&quot; as ...
      state &quot;OpenSearchIndexScan&quot; as OpenSearchIndexScan

      CursorCloseOperator --&gt; ProjectOperator
      ProjectOperator --&gt; ...
      ... --&gt; OpenSearchIndexScan
    }

    [*] --&gt; Unresolved : QueryPlanner
    Unresolved --&gt; Logical : Planner
    Logical --&gt; Optimized : Optimizer
    Optimized --&gt; Physical : Implementor
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">CursorCloseOperator</span></code> provides a dummy (empty, since not used) <code class="docutils literal notranslate"><span class="pre">Schema</span></code>, does not perform <code class="docutils literal notranslate"><span class="pre">open</span></code> and always returns <code class="docutils literal notranslate"><span class="pre">false</span></code> by <code class="docutils literal notranslate"><span class="pre">hasNext</span></code>. Such behavior makes it a no-op operator which blocks underlying Physical Plan Tree from issuing any search request, but does not block auto-close provided by <code class="docutils literal notranslate"><span class="pre">AutoCloseable</span></code>. Default close action clears scroll context.
Regular paging doesn’t execute scroll clear, because it checks whether paging is finished or not and raises a flag to prevent clear. This check performed when search response recevied, what never happen due to <code class="docutils literal notranslate"><span class="pre">CursorCloseOperator</span></code>.</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">OpenSearchScrollRequest</span><span class="p">:</span>
  <span class="nb">bool</span> <span class="n">needClean</span> <span class="o">=</span> <span class="n">true</span>

  <span class="k">def</span> <span class="nf">search</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="n">needClean</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">isEmpty</span><span class="p">()</span>

  <span class="k">def</span> <span class="nf">clean</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">needClean</span><span class="p">:</span>
      <span class="n">clearScroll</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CursorCloseOperator</span><span class="p">(</span><span class="n">PhysicalPlan</span><span class="p">):</span>
  <span class="n">PhysicalPlan</span> <span class="n">tree</span>
  <span class="k">def</span> <span class="nf">open</span><span class="p">:</span>
    <span class="k">pass</span>
    <span class="c1"># no-op, don&#39;t propagate `open` of underlying plan tree</span>

  <span class="k">def</span> <span class="nf">hasNext</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">false</span>
</pre></div>
</div>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PhysicalPlan</span><span class="p">:</span>
  <span class="k">def</span> <span class="nf">open</span><span class="p">:</span>
    <span class="n">innerPlan</span><span class="o">.</span><span class="n">open</span><span class="p">()</span>

  <span class="k">def</span> <span class="nf">close</span><span class="p">:</span>
    <span class="n">innerPlan</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</section>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Example</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;workshop participant.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="../_sources/dev/Pagination-v2.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>